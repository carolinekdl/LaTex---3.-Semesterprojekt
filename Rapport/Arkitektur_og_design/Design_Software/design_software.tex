\section{Softwaredesign}
Softwaren er designet ud fra paradigmet om lav kobling. Dette er først og fremmest gjort ved, at dele de forskellige use cases op i egne klasser med interfaces imellem for at opfylde open-closed princippet. Derudover er der brugt dependency injection, som ligeledes fremmer en lav kobling. Denne opbygning gør det også muligt at benytte scrum  da hver use case har sin egen klasse i softwaren, og man dermed kan arbejde individuelt på hver sin use case. Desuden bliver det også lettere at teste og lokalisere eventuelle fejl. Derudover er det i fremtiden, lettere at genbruge softwaren i nye applikationer, samt at udvide uden at skulle lave alt for mange ændringer i koden. 

Et knudepunkt i softwaren er klassen HovedmenuGUI, som har mange ansvar. Dette ansvar er forsøgt mindsket ved at lave en GuiFactory klasse, som sørger for at oprette instanser af de tre andre GUI’er. Dette sikrer også, at det ville være nemt at tilføje en anden GUI, hvis softwaren skal udvides med en ny funktionalitet.
Kommunikationen mellem datalaget og logiklaget er designet ud fra producer-consumer princippet. Dette var en oplagt løsning, da vores måleenhed hele tiden producerer data, som skal bruges og behandles af controllerklasserne i logiklaget. En anden vigtig feature ved producer-consumer er, at en datakø er indbygget, som sørger for, at der ikke går måledata tabt mellem datalaget og logiklaget, som kører i hver sin tråd. Køen har vi realiseret ved at bruge AutoResetEvents, som forhindrer, at producertråden overskriver måledata, inden de er blevet consumed i logiklaget. På den måde undgås fejl i kommunikationen mellem datalaget og logiklaget.

Mellem logiklaget og præsentationslaget var det i første omgang planen at bruge observer pattern. Det viste sig dog, at dette ikke var særlig hensigtsmæssigt, da der er forskel på, hvor tit blodtryksgrafen og beregningerne på hovedmenuen skal opdateres. Dette gjorde det vanskeligt at bruge observer standardmønstret. Der var behov for en mere generisk løsning. Kommunikationen mellem logiklaget og præsentationslaget blev i stedet løst ved at bruge events, som på mange måder minder om observer, men er en mere fleksibel metode, der er indbygget i .NET frameworket. Dette viste sig også at være en god løsning på kommunikation mellem alarmeringscontrolleren og hovedmenuen. Her blev der altså afgivet fra ASE-modellen, da der blev arbejdet iterativt med software arkitekturen. Dette har generelt 

En anden udfordring var en samplefrekvens på 1000 Hz og en computerskærm, der opdaterer med 60 Hz. For at undgå en nedsampling af signalet i softwaren, blev det besluttet, at grafen opdaterer med 100 punkter af gangen 10 gange i sekundet. Opdateringsfrekvensen på skærmen bliver således kun 10 Hz. Blodtryksgrafen opdaterer altså ikke helt så smooth, men dette blev besluttet som et fint kompromis, da der ikke mistes information i signalet på grund nedsampling.


